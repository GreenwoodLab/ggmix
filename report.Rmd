---
title: "Initial Implementation of penfam algorithm"
author: "Sahir"
date: "May 10, 2017"
output:
  html_document:
    toc: true
    toc_float: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(digits=4, scipen = 999)
rm(list=ls())
```

## Source code

The source code used to create this report, including the main function can be found at https://github.com/sahirbhatnagar/penfam. 

```{r}
# block relaxation for fitting the penfam model
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/fitting.R")
source("~/git_repositories/penfam/R/fitting.R")
# utility functions 
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/functions.R")
source("~/git_repositories/penfam/R/functions.R")
# print, plot and predict methods 
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/methods.R")
source("~/git_repositories/penfam/R/methods.R")
# plotting functions
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/plot.R")
source("~/git_repositories/penfam/R/plot.R")
```


## Required Packages

```{r}
pacman::p_load(MASS) 
pacman::p_load(glmnet)
pacman::p_load(progress)
pacman::p_load(magrittr)
```


## Simulation Details

### Kinship Matrix and Eigen Decomposition
```{r}
set.seed(12345678)
# Kinship matrix from Karim
load("~/Dropbox/PhD/Year4/penfam/data/kin1.Rdata")
Phi <- 2 * kin1
dim(Phi)
Phi[1:10, 1:10]

# eigen decomposition
Phi_eigen <- eigen(Phi)

# eigenvalues
Lambda <- Phi_eigen$values
any(Lambda < 1e-3)
all(Lambda > 0)
rcond(Phi)
kappa(Phi)
```

### Simulation parameters
```{r}
eta <- 0.25
sigma2 <- 3

# intercept
b0 <- 3 

# true betas
b <- c(runif(10, 0.8,1.2), rep(0,80), runif(10, -1.2, -0.8)) 
```

### Simulate data
```{r}
# number of predictors
p <- length(b)

n <- nrow(Phi)

# polygenic random effect
P <- mvrnorm(1, mu = rep(0, n), Sigma = eta * sigma2 * Phi)

# environment random effect
E <- mvrnorm(1, mu = rep(0, n), Sigma = (1 - eta) * sigma2 * diag(n))

# independent predictors
X <- mvrnorm(n, rep(1,p), diag(p))
dim(X)

# response
Y <- b0 + X %*% b + P + E
```


## Fit the penfam model

This outputs an object of class `penfam`. We fit using the option `exact = TRUE` and `exact = FALSE`.
```{r}
system.time(
  exact <- penfam(x = X, y = Y, phi = Phi, 
                 thresh_glmnet = 1e-10,
                 epsilon = 1e-4,
                 tol.kkt = 1e-3,
                 nlambda = 100,
                 exact = T,
                 an = log(log(n)) * log(n)) 
  )

exact = approx
plot(exact, type = "BIC")
predict(exact, type = "nonzero", s = exact$lambda_min)

View(lmmlasso:::plot.lmmlasso)
qqnorm(exact$randomeff[, exact$lambda_min])
qqline(exact$randomeff[, exact$lambda_min], col = "red")

qqnorm(exact$residuals[, exact$lambda_min])
qqline(exact$residuals[, exact$lambda_min], col = "red")


plot(exact$randomeff[, exact$lambda_min],
     P, xlab = "estimated", ylab = "truth")
abline(a = 0, b = 1, col = "red")
cor(exact$randomeff[, exact$lambda_min],P)

# Tukey-Anscombe
plot(exact$fitted[, exact$lambda_min],
     exact$residuals[, exact$lambda_min])
abline(a = 0, b = 0, col = "red")

lmmlasso:::plot.lmmlasso()

plot(exact$fitted[, exact$lambda_min], Y)
abline(a = 0, b = 1, col = "red")
cor(exact$fitted[, exact$lambda_min],Y)



system.time(
approx <- penfam(x = X, y = Y, phi = Phi, 
                 thresh_glmnet = 1e-10,
                 epsilon = 1e-4,
                 tol.kkt = 1e-3,
                 nlambda = 100,
                 exact = F,
                 an = log(log(n)) * log(n))
)

par(mfrow=c(2,1))
plot(exact, type = "BIC")
plot(approx, type = "BIC")
cbind(
  predict(exact, type = "nonzero", s = exact$lambda_min),
  predict(approx, type = "nonzero", s = approx$lambda_min)
)

all(exact$x[,"converged"]==1)
all(approx$x[,"converged"]==1)

dev.off()
plot(predict(exact, type = "nonzero", s = exact$lambda_min),
  predict(approx, type = "nonzero", s = approx$lambda_min))
abline(a = 0, b = 1, col = "red")

class(res)
res$x

# res$coef[,c("s1","s2"), drop = F]
# nonzeroCoef(res$coef, bystep = T)
```

Print method:
```{r}
res
```

## Coefficients at Minimum BIC

```{r}
coef(res, s=res$lambda_min)
```

## Non-zero Coefficients at Minimum BIC

```{r}
predict(res, type = "nonzero", s = res$lambda_min)
```


## Plot of Coefficient Paths

```{r}
plot(res, xvar = "norm")
plot(res, xvar = "lambda")
plot(res, xvar = "dev")
```

## Plot of BIC as a function of Tuning parameters

```{r}
plot(res, type = "BIC")
```


## Compare Estimated vs. Truth

```{r, fig.keep='last'}
plot(coef(res, s = res$lambda_min), pch = 19, col = "red", ylim = range(c(b0,b, eta, sigma2,drop(coef(res, s = res$lambda_min)))))
points(seq_along(c(b0,b, eta, sigma2)), c(b0,b, eta, sigma2), pch = 19, col = "blue")
legend("bottomleft",
       legend = c("Estimated", "Truth"),
       col = c("red","blue"),
       pch = c(19, 19),
       bg = "gray90")
```



