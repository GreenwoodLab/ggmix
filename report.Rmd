---
title: "Initial Implementation of penfam algorithm"
author: "Sahir"
date: "May 10, 2017"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = FALSE)
options(digits=4, scipen = 999)
rm(list=ls())
```

## Source code

The source code used to create this report, including the main function can be found at https://github.com/sahirbhatnagar/penfam. 

```{r}
# block relaxation for fitting the penfam model
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/fitting.R")
source("~/git_repositories/penfam/R/fitting.R")
# utility functions 
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/functions.R")
source("~/git_repositories/penfam/R/functions.R")
# print, plot and predict methods 
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/methods.R")
source("~/git_repositories/penfam/R/methods.R")
# plotting functions
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/plot.R")
source("~/git_repositories/penfam/R/plot.R")
```


## Required Packages

```{r}
pacman::p_load(MASS) 
pacman::p_load(glmnet)
pacman::p_load(progress)
pacman::p_load(magrittr)
```


## Simulation Details

### Kinship Matrix and Eigen Decomposition
```{r}
set.seed(12345678)
# Kinship matrix from Karim
load("~/Dropbox/PhD/Year4/penfam/data/kin1.Rdata")
Phi <- 2 * kin1
dim(Phi)
Phi[1:10, 1:10]

# eigen decomposition
Phi_eigen <- eigen(Phi)

# eigenvalues
Lambda <- Phi_eigen$values
any(Lambda < 1e-3)
all(Lambda > 0)
rcond(Phi)
kappa(Phi)
```

### Simulation parameters
```{r}
eta <- 0.25
sigma2 <- 3

# intercept
b0 <- 3 

# true betas
b <- c(runif(10, 0.8,1.2), rep(0,80), runif(10, -1.2, -0.8)) 
```

### Simulate data
```{r}
# number of predictors
p <- length(b)

n <- nrow(Phi)

# polygenic random effect
P <- mvrnorm(1, mu = rep(0, n), Sigma = eta * sigma2 * Phi)

# environment random effect
E <- mvrnorm(1, mu = rep(0, n), Sigma = (1 - eta) * sigma2 * diag(n))

# independent predictors
X <- mvrnorm(n, rep(1,p), diag(p))
dim(X)

# response
Y <- b0 + X %*% b + P + E
```


## A note on using `glmnet`

As per [Appendix 2 of the `glmnet` vignette](https://web.stanford.edu/~hastie/Papers/Glmnet_Vignette.pdf), the recommended way to obtain a lasso solution for a single value of $\lambda$ is to
> fit the entire lasso or elastic-net path without specifying lambda, letting it chose its own sequence. Then make a call to coef or predict (using the exact = TRUE option) and provide the requested $\lambda$ to extract the corresponding coefficients. 

We provide these two main options for fitting the `penfam` model by specifying the `exact` argument:
- `exact = TRUE`: this will use the exact value of lambda provided and re-fit the model using `glmnet`
- `exact = FALSE`: this will use a linear interpolation 
In both cases, the entire lasso path is being fit.

## Fit the penfam model with `exact = TRUE`

We first fit using the option `exact = TRUE`

```{r}
system.time(
  exact <- penfam(x = X, 
                  y = Y, 
                  phi = Phi, 
                  thresh_glmnet = 1e-10,
                  epsilon = 1e-9,
                  tol.kkt = 1e-3,
                  nlambda = 100,
                  exact = TRUE,
                  an = log(log(n)) * log(n),
                  lambda_min_ratio  = ifelse(n < p, 0.01, 0.001),
                  eta_init = 0.5,
                  maxit = 100) 
)
```

Print method:
```{r}
exact
```


### KKT Checks

```{r}
exact$result[,c(-2,-3,-4,-10)]
```



### Coefficients at Minimum BIC

```{r}
coef(exact, s = exact$lambda_min)
```

### Non-zero Coefficients at Minimum BIC

```{r}
predict(exact, type = "nonzero", s = exact$lambda_min)
```

### Plot of Coefficient Paths

```{r}
plot(exact, type = "coef", xvar = "norm")
plot(exact, type = "coef", xvar = "lambda")
plot(exact, type = "coef", xvar = "dev")
```


### Plot of BIC as a function of Tuning parameters

```{r}
plot(exact, type = "BIC")
```


### Compare Estimated vs. Truth

```{r, fig.keep='last'}
plot(coef(exact, s = exact$lambda_min), 
     pch = 19, col = "red", 
     ylim = range(c(b0, b, eta, sigma2, drop(coef(exact, s = exact$lambda_min)))))

points(seq_along(c(b0, b, eta, sigma2)), c(b0, b, eta, sigma2), pch = 19, col = "blue")

legend("bottomleft",
       legend = c("Estimated", "Truth"),
       col = c("red","blue"),
       pch = c(19, 19),
       bg = "gray90")
```


### Prediction of Random Effects

```{r}
plot(exact, type = c("QQranef"), s = exact$lambda_min)
```


### Tukey-Anscombe Plot

```{r}
plot(exact, type = c("Tukey"), s = exact$lambda_min)
```


### Residuals

```{r}
plot(exact, type = c("QQresid"), s = exact$lambda_min)
```


### Fitted vs. Observed response


```{r}
plot(exact, type = c("fitted"), s = exact$lambda_min)
```



## Fit the penfam model with `exact = FALSE`

Now we fit using the option `exact = FALSE`

```{r}
system.time(
  approx <- penfam(x = X, 
                   y = Y, 
                   phi = Phi, 
                   thresh_glmnet = 1e-10,
                   epsilon = 1e-6,
                   tol.kkt = 1e-4,
                   nlambda = 100,
                   exact = FALSE,
                   an = log(log(n)) * log(n),
                   lambda_min_ratio  = ifelse(n < p, 0.01, 0.001),
                   eta_init = 0.5,
                   maxit = 100) 
)
```

Print method:
```{r}
approx
```


### KKT Checks

```{r}
approx$result[,c(-2,-3,-4,-10)]
```



### Coefficients at Minimum BIC

```{r}
coef(approx, s = approx$lambda_min)
```

### Non-zero Coefficients at Minimum BIC

```{r}
predict(approx, type = "nonzero", s = approx$lambda_min)
```

### Plot of Coefficient Paths

```{r}
plot(approx, type = "coef", xvar = "norm")
plot(approx, type = "coef", xvar = "lambda")
plot(approx, type = "coef", xvar = "dev")
```


### Plot of BIC as a function of Tuning parameters

```{r}
plot(approx, type = "BIC")
```


### Compare Estimated vs. Truth

```{r, fig.keep='last'}
plot(coef(approx, s = approx$lambda_min), 
     pch = 19, col = "red", 
     ylim = range(c(b0, b, eta, sigma2, drop(coef(approx, s = approx$lambda_min)))))

points(seq_along(c(b0, b, eta, sigma2)), c(b0, b, eta, sigma2), pch = 19, col = "blue")

legend("bottomleft",
       legend = c("Estimated", "Truth"),
       col = c("red","blue"),
       pch = c(19, 19),
       bg = "gray90")
```


### Prediction of Random Effects

```{r}
plot(approx, type = c("QQranef"), s = approx$lambda_min)
```


### Tukey-Anscombe Plot

```{r}
plot(approx, type = c("Tukey"), s = approx$lambda_min)
```


### Residuals

```{r}
plot(approx, type = c("QQresid"), s = approx$lambda_min)
```


### Fitted vs. Observed response


```{r}
plot(approx, type = c("fitted"), s = approx$lambda_min)
```




## Compare Exact to Approximate

```{r}
exact_coef <- coef(exact, s = exact$lambda_min)
approx_coef <- coef(approx, s = approx$lambda_min)
plot(drop(exact_coef),
     drop(approx_coef),
     xlab = "exact", ylab = "approximate", main = "Estimated parameters at minimum BIC")
```

```{r}
cbind(exact_coef, approx_coef)
```


### Pearson Correlation
```{r}
cor(drop(exact_coef), drop(approx_coef))
```

### Spearman Correlation
```{r}
cor(drop(exact_coef), drop(approx_coef),
    method = "spearman")
```


