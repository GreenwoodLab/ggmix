---
title: "Initial Implementation of penfam algorithm"
author: "Sahir"
date: "May 10, 2017"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(digits=4)
rm(list=ls())
```

## Source code

The source code used to create this report, including the main function can be found at https://github.com/sahirbhatnagar/penfam. 

```{r}
# block relaxation for fitting the penfam model
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/fitting.R")
source("~/git_repositories/penfam/R/fitting.R")
# utility functions 
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/functions.R")
source("~/git_repositories/penfam/R/functions.R")
# print, plot and predict methods 
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/methods.R")
source("~/git_repositories/penfam/R/methods.R")
# plotting functions
# source("https://raw.githubusercontent.com/sahirbhatnagar/penfam/master/R/plot.R")
source("~/git_repositories/penfam/R/plot.R")
```


## Required Packages

```{r}
pacman::p_load(MASS) 
pacman::p_load(glmnet)
pacman::p_load(progress)
```


## Simulation Details

### Kinship Matrix and Eigen Decomposition
```{r}
# Kinship matrix from Karim
load("~/Dropbox/PhD/Year4/penfam/data/kin1.Rdata")
Phi <- 2 * kin1
dim(Phi)
Phi[1:10, 1:10]

# eigen decomposition
Phi_eigen <- eigen(Phi)

# eigenvalues
Lambda <- Phi_eigen$values
any(Lambda < 1e-3)
all(Lambda > 0)
rcond(Phi)
kappa(Phi)
```

### Simulation parameters
```{r}
eta <- 0.25
sigma2 <- 3

# intercept
b0 <- 3 

# true betas
b <- c(runif(10, 0.8,1.2), rep(0,980), runif(10, -1.2, -0.8)) 
```

### Simulate data
```{r}
# number of predictors
p <- length(b)

n <- nrow(Phi)

# polygenic random effect
P <- mvrnorm(1, mu = rep(0, n), Sigma = eta * sigma2 * Phi)

# environment random effect
E <- mvrnorm(1, mu = rep(0, n), Sigma = (1 - eta) * sigma2 * diag(n))

# independent predictors
X <- mvrnorm(n, rep(1,p), diag(p))
dim(X)

# response
Y <- b0 + X %*% b + P + E
```


## Fit the penfam model

This outputs an object of class `penfam`:
```{r}
# lambda_min_ratio is what I call \tau in the paper
# in the paragraph after equation 20
system.time(
  res <- penfam(x = X, y = Y, phi = Phi, lambda_min_ratio = 0.001, 
                nlambda = 100,
                an = log(log(n)) * log(n))
)
class(res)
res$x
# res$coef[,c("s1","s2"), drop = F]
# nonzeroCoef(res$coef, bystep = T)
```

Print method:
```{r}
res
```

## Coefficients at Minimum BIC

```{r}
coef(res, s=res$lambda_min)
```

## Non-zero Coefficients at Minimum BIC

```{r}
predict(res, type = "nonzero", s = res$lambda_min)
```


## Plot of Coefficient Paths

```{r}
plot(res, xvar = "norm")
plot(res, xvar = "lambda")
plot(res, xvar = "dev")
```

## Plot of BIC as a function of Tuning parameters

```{r}
plot(res, type = "BIC")
```


## Compare Estimated vs. Truth

```{r, fig.keep='last'}
plot(coef(res, s = res$lambda_min), pch = 19, col = "red", ylim = range(c(b0,b, eta, sigma2,drop(coef(res, s = res$lambda_min)))))
points(seq_along(c(b0,b, eta, sigma2)), c(b0,b, eta, sigma2), pch = 19, col = "blue")
legend("bottomleft",
       legend = c("Estimated", "Truth"),
       col = c("red","blue"),
       pch = c(19, 19),
       bg = "gray90")
```



